# ------------------------------
# S-Curve / Logistic Growth Forecast Workflow
# ------------------------------

# Load libraries
library(forecast)
library(Metrics)
library(ggplot2)
library(minpack.lm)  # for nlsLM (robust nonlinear least squares)

# ------------------------------
# Example Data
# ------------------------------
data <- c(120,130,125,140,150,145,160,155,165,170,175,180,
          185,190,195,200,205,210,215,220,225,230,235,240)
data_ts <- ts(data, start=c(2019,1), frequency=12)

# ------------------------------
# Train/Test Split (optional)
# ------------------------------
train_ts <- window(data_ts, end=c(2019,9))
test_ts  <- window(data_ts, start=c(2019,10))
h <- length(test_ts)

# ------------------------------
# Define Logistic Growth (S-curve) Model
# ------------------------------
# Logistic function: y = K / (1 + exp(-r*(t - t0)))
# K = max potential, r = growth rate, t0 = midpoint
time <- 1:length(train_ts)
logistic_model <- nlsLM(
  train_ts ~ K / (1 + exp(-r * (time - t0))),
  start = list(K = max(train_ts) * 1.2, r = 0.1, t0 = length(train_ts)/2)
)
summary(logistic_model)

# ------------------------------
# Forecast
# ------------------------------
time_forecast <- 1:(length(train_ts) + h)
forecast_values <- predict(logistic_model, newdata = list(time = time_forecast))
plot(forecast_values)

# ------------------------------
# Error Metrics
# ------------------------------
# Only calculate on test set
rmse_scurve <- rmse(as.numeric(test_ts), forecast_values[(length(train_ts)+1):length(time_forecast)])
mae_scurve  <- mae(as.numeric(test_ts), forecast_values[(length(train_ts)+1):length(time_forecast)])
mape_scurve <- mean(abs((as.numeric(test_ts) - forecast_values[(length(train_ts)+1):length(time_forecast)])/as.numeric(test_ts))) * 100

Compare_Models <- data.frame(
  Model = "S-Curve Logistic",
  RMSE  = rmse_scurve,
  MAE   = mae_scurve,
  MAPE  = mape_scurve
)
print(Compare_Models)



# if its the best model 
# ------------------------------
# Fit Final Model on Full Dataset if Best
# ------------------------------
final_h <- ...  # forecast next 6 periods
time_full <- 1:(length(data_ts) + final_h)
final_model <- nlsLM(
  data_ts ~ K / (1 + exp(-r * (time_full - t0))),
  start = list(K = max(data_ts) * 1.2, r = 0.1, t0 = length(data_ts)/2)
)
final_forecast <- predict(final_model, newdata = list(time_full = time_full))
final_forecast
plot(final_forecast)

# ------------------------------
# Plot
# ------------------------------
# Dynamic dates for plotting
start_year   <- start(data_ts)[1]
start_period <- start(data_ts)[2]
start_date   <- as.Date("2019-01-01")  #("YYYY-MM-DD")  # exact first date of your datase

n_total <- length(data_ts) + final_h
freq <- frequency(data_ts)

date_seq <- switch(as.character(freq),
                   "12" = seq(start_date, by="month",   length.out=n_total),
                   "4"  = seq(start_date, by="quarter", length.out=n_total),
                   "52" = seq(start_date, by="week",    length.out=n_total),
                   "1"  = seq(start_date, by="year",    length.out=n_total),
                   seq(start_date, by="day", length.out=n_total))

forecast_df <- data.frame(
  Date     = date_seq,
  Value    = c(as.numeric(data_ts), rep(NA, final_h)),
  Forecast = final_forecast
)
forecast_df

ggplot(forecast_df, aes(x=Date)) +
  geom_line(aes(y=Value), color="black") +
  geom_line(aes(y=Forecast), color="blue") +
  labs(title="S-Curve Logistic Forecast on Full Dataset", y="Value", x="Date")
